import{o as a,c as r,k as e,l as t,a as o,Q as i,f as n}from"./chunks/framework.21a77088.js";const s=e("h1",{id:"什么是-emnapi",tabindex:"-1"},[o("什么是 emnapi "),e("a",{class:"header-anchor",href:"#什么是-emnapi","aria-label":'Permalink to "什么是 emnapi"'},"​")],-1),l=["src"],d=i('<p><code>emnapi</code> 适用于 Emscripten 的 <a href="https://nodejs.org/docs/v16.15.0/api/n-api.html" target="_blank" rel="noreferrer">Node-API</a> 接近完整的实现，从 v0.29.0 版本开始支持 <a href="https://github.com/WebAssembly/wasi-sdk" target="_blank" rel="noreferrer">wasi-sdk</a> 和 clang <code>wasm32-unknown-unknown</code> 构建目标。</p><h2 id="动机" tabindex="-1">动机 <a class="header-anchor" href="#动机" aria-label="Permalink to &quot;动机&quot;">​</a></h2><p>本项目的目标是：</p><ul><li>帮助用户将他们的或现有的 Node-API 原生插件尽可能少地更改代码移植到 wasm。</li><li>使运行时行为尽可能匹配原生 Node.js。</li></ul><h2 id="为什么不用-embind" tabindex="-1">为什么不用 <code>embind</code> <a class="header-anchor" href="#为什么不用-embind" aria-label="Permalink to &quot;为什么不用 `embind`&quot;">​</a></h2><p>如果你不需要在浏览器和 Node.js 上运行相同的 Node-API 绑定代码，<code>embind</code> 非常好。使用 <code>embind</code> 编译成 wasm 也可以让你的代码同时在浏览器和 Node.js 上运行，但是当以 Node.js 为目标时，我们更倾向于编译到 Node.js 原生模块而不是 wasm 以获得原生性能。因此，在这种情况下，你可能需要为 Node.js 编写 Node-API 绑定，并为 Emscripten WebAssembly 编写 <code>embind</code> 绑定。你只是想让你的原生依赖项可以在 JavaScript 世界中使用，但你正在做重复的事情。</p><p>emnapi 的另一个使用场景是将 Node-API 原生扩展跑在 <a href="https://stackblitz.com/" target="_blank" rel="noreferrer">StackBlitz</a> 的 WebContainer 上。</p><h2 id="浏览器兼容性" tabindex="-1">浏览器兼容性 <a class="header-anchor" href="#浏览器兼容性" aria-label="Permalink to &quot;浏览器兼容性&quot;">​</a></h2><p>先把 IE 忘掉吧。</p><p><code>emnapi</code> 发布的 JavaScript 代码都是 ES5，但需要 ES6 全局变量，例如 <code>WeakMap</code>，并且<a href="/emnapi-docs/zh/reference/list.html">一些 API</a> 需要 <code>BigInt</code>、<code>WeakRef</code> 和 <code>FinalizationRegistry</code>，这在 ES 标准中是非常新的，所以如果你用到了这些 API，你的代码将无法在稍微旧点的浏览器或旧版本 Node.js 上运行。你可以点击链接查看哪些浏览器支持 <a href="https://www.caniuse.com/?search=WeakRef" target="_blank" rel="noreferrer">WeakRef</a> 和 <a href="https://www.caniuse.com/?search=FinalizationRegistry" target="_blank" rel="noreferrer">FinalizationRegistry</a>。以 Chrome 为例，推荐目标浏览器版本高于 Chrome 84。</p><h2 id="可用于生产环境吗" tabindex="-1">可用于生产环境吗 <a class="header-anchor" href="#可用于生产环境吗" aria-label="Permalink to &quot;可用于生产环境吗&quot;">​</a></h2><p>所有 Node.js 官方测试通过！功能可以得到保证。目前已经有著名开源项目正在或将要使用 emnapi：</p><ul><li>StackBlitz 上的 <a href="https://github.com/lovell/sharp" target="_blank" rel="noreferrer">sharp</a> 正在使用 emnapi，见<a href="https://blog.stackblitz.com/posts/bringing-sharp-to-wasm-and-webcontainers/" target="_blank" rel="noreferrer">官方博客</a>！</li><li><a href="https://github.com/napi-rs/napi-rs" target="_blank" rel="noreferrer">napi-rs</a> 在 2.14.0 版本<a href="https://github.com/napi-rs/napi-rs/pull/1669" target="_blank" rel="noreferrer">已集成 emnapi</a></li><li><a href="https://github.com/mmomtchev/magickwand.js" target="_blank" rel="noreferrer">node-magickwand</a> 作为 <a href="https://github.com/swig/swig" target="_blank" rel="noreferrer">SWIG</a> 的 Node-API 示例项目已接入 emnapi</li></ul><p>经过简单测试，发现一般场景下绑定的调用开销比 embind 略大，但应在可接受的范围内。</p><p>你也可以试试<a href="https://github.com/toyobayashi/emnapi/pulls" target="_blank" rel="noreferrer">让 emnapi 变得更好</a>！</p><h2 id="赞助者" tabindex="-1">赞助者 <a class="header-anchor" href="#赞助者" aria-label="Permalink to &quot;赞助者&quot;">​</a></h2><p align="center"><a href="https://cdn.jsdelivr.net/gh/toyobayashi/toyobayashi/sponsorkit/sponsors.svg"><img src="https://cdn.jsdelivr.net/gh/toyobayashi/toyobayashi/sponsorkit/sponsors.svg"></a></p>',17),g=JSON.parse('{"title":"什么是 emnapi","description":"","frontmatter":{"sidebarDepth":2},"headers":[],"relativePath":"zh/guide/index.md","filePath":"zh/guide/index.md","lastUpdated":1706611505000}'),h={name:"zh/guide/index.md"},f=Object.assign(h,{setup(c){return(p,m)=>(a(),r("div",null,[s,e("img",{src:t(n)("/emnapi.svg"),alt:"emnapi logo",width:"256"},null,8,l),d]))}});export{g as __pageData,f as default};
