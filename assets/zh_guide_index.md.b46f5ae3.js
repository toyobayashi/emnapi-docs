import{o as a,c as r,b as e,u as i,d as t,a as n,w as d}from"./app.d35415a2.js";const s=e("h1",{id:"什么是-emnapi",tabindex:"-1"},[t("什么是 emnapi "),e("a",{class:"header-anchor",href:"#什么是-emnapi","aria-hidden":"true"},"#")],-1),o=["src"],c=n('<p><code>emnapi</code> 适用于 Emscripten 的 <a href="https://nodejs.org/docs/v16.15.0/api/n-api.html" target="_blank" rel="noreferrer">Node-API</a> 接近完整的实现，从 v0.29.0 版本开始支持 <a href="https://github.com/WebAssembly/wasi-sdk" target="_blank" rel="noreferrer">wasi-sdk</a> 和 clang <code>wasm32-unknown-unknown</code> 构建目标，<a href="https://github.com/napi-rs/napi-rs/issues/796" target="_blank" rel="noreferrer">napi-rs 正在支持中</a>。</p><h2 id="动机" tabindex="-1">动机 <a class="header-anchor" href="#动机" aria-hidden="true">#</a></h2><p>本项目的目标是：</p><ul><li>帮助用户将他们的或现有的 Node-API 原生插件尽可能少地更改代码移植到 wasm。</li><li>使运行时行为尽可能匹配原生 Node.js。</li></ul><h2 id="为什么不用-embind" tabindex="-1">为什么不用 <code>embind</code> <a class="header-anchor" href="#为什么不用-embind" aria-hidden="true">#</a></h2><p>如果你不需要在浏览器和 Node.js 上运行相同的 Node-API 绑定代码，<code>embind</code> 非常好。使用 <code>embind</code> 编译成 wasm 也可以让你的代码同时在浏览器和 Node.js 上运行，但是当以 Node.js 为目标时，我们更倾向于编译到 Node.js 原生模块而不是 wasm 以获得原生性能。因此，在这种情况下，你可能需要为 Node.js 编写 Node-API 绑定，并为 Emscripten WebAssembly 编写 <code>embind</code> 绑定。你只是想让你的原生依赖项可以在 JavaScript 世界中使用，但你正在做重复的事情。</p><p>emnapi 的另一个使用场景是将 Node-API 原生扩展跑在 <a href="https://stackblitz.com/" target="_blank" rel="noreferrer">StackBlitz</a> 的 WebContainer 上。</p><h2 id="浏览器兼容性" tabindex="-1">浏览器兼容性 <a class="header-anchor" href="#浏览器兼容性" aria-hidden="true">#</a></h2><p>先把 IE 忘掉吧。</p><p><code>emnapi</code> 发布的 JavaScript 代码都是 ES5，但需要 ES6 全局变量，例如 <code>WeakMap</code>，并且<a href="/emnapi-docs/zh/reference/list.html">一些 API</a> 需要 <code>BigInt</code>、<code>WeakRef</code> 和 <code>FinalizationRegistry</code>，这在 ES 标准中是非常新的，所以如果你用到了这些 API，你的代码将无法在稍微旧点的浏览器或旧版本 Node.js 上运行。你可以点击链接查看哪些浏览器支持 <a href="https://www.caniuse.com/?search=WeakRef" target="_blank" rel="noreferrer">WeakRef</a> 和 <a href="https://www.caniuse.com/?search=FinalizationRegistry" target="_blank" rel="noreferrer">FinalizationRegistry</a>。以 Chrome 为例，推荐目标浏览器版本高于 Chrome 84。</p><h2 id="可用于生产环境吗" tabindex="-1">可用于生产环境吗 <a class="header-anchor" href="#可用于生产环境吗" aria-hidden="true">#</a></h2><p>所有 Node.js 官方测试通过！功能可以得到保证。</p><p>经过简单测试，发现一般场景下绑定的调用开销比 embind 略大，但应在可接受的范围内。</p><p>1.0 版本即将到来，目前并没有发布，因为用于内部实现的运行时 API 可能还需要频繁重构与变更，但这不影响用户使用 Node-API 本身的稳定 API。</p><p>你也可以试试<a href="https://github.com/toyobayashi/emnapi/pulls" target="_blank" rel="noreferrer">让 emnapi 变得更好</a>！</p>',15),b=JSON.parse('{"title":"什么是 emnapi","description":"","frontmatter":{"sidebarDepth":2},"headers":[{"level":2,"title":"动机","slug":"动机","link":"#动机","children":[]},{"level":2,"title":"为什么不用 embind","slug":"为什么不用-embind","link":"#为什么不用-embind","children":[]},{"level":2,"title":"浏览器兼容性","slug":"浏览器兼容性","link":"#浏览器兼容性","children":[]},{"level":2,"title":"可用于生产环境吗","slug":"可用于生产环境吗","link":"#可用于生产环境吗","children":[]}],"relativePath":"zh/guide/index.md","lastUpdated":1682612480000}'),l={name:"zh/guide/index.md"},u=Object.assign(l,{setup(h){return(p,m)=>(a(),r("div",null,[s,e("img",{src:i(d)("/emnapi.svg"),alt:"emnapi logo",width:"256"},null,8,o),c]))}});export{b as __pageData,u as default};
